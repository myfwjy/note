---
title: 其他
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---

### ThreadLocal
以线程为作用域维护变量。用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。比如安卓中的handler机制。
ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。
Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问，用于在多个线程间通信时能够获得数据共享。 
### Synchronized  Lock Volatite
Synchronized是悲观锁机制，独占锁。而Locks.ReentrantLock是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。
公平锁：按顺序获取锁，如果已经获取锁的线程再次申请，state状态加1，只有在state等于0时才释放锁。
非公平锁:上一个使用者释放，下一个使用者唤醒时，如果有其他申请，可能插队。
https://blog.csdn.net/yanyan19880509/article/details/52345422
Volatite只能保证可见性，即变更立即写入内存，其他线程必须从主内存中获取，但是不能保证原子性，可能读取时阻塞，写入是值已经不是当初读取的了。
### string stringbuffer stringbuilder
string是不可改变的对象，每次修改时，实际上是创建了一个新的string。stringbuffer是可改变对象，是对一个对象的操作，线程安全。stringbuilder线程不安全。
### fail-fast
java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。 
例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。
### 装箱和拆箱
装箱，基本数据类型包装成对象类型。拆箱，对象类型转换成基本数据类型。
### 反射
反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
泛型的本质是参数化类型，也就是操作的数据类型被指定为一个参数。例如，使用List的时候指定为List，有利于代码简单安全，将运行时错误提前到编译时错误。而java在运行中会去泛型化。
### string是不可变类
String是不可变的。
1、因为不可变，所以字符串池中才可以多个变量指向一个字符串，而不用保存多个相同的字符串，否则字符串改变了，指向他的变量也会改变。
2、创建时hashcode就确定，很适合作为hashmap的key。
3、自带线程安全，同一个字符串可以被多个线程共享。
### Spring Bean的作用域 Prototype Request
任何时候使用getBean，Prototype都会返回一个新对象，而在一个httpRequest中request只会返回一个相同对象。
HttpRequest scope
Mark mark1 = context.getBean("mark");
Mark mark2 = context.getBean("mark");
mark1 == mark2; //This will return true

Prototype scope

Mark mark1 = context.getBean("mark");
Mark mark2 = context.getBean("mark");
mark1 == mark2; //This will return false
### B+树
B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。
### 索引
Mysql的索引是一个数据结构，旨在使数据库高效的查找数据。 
常用的数据结构是B+Tree，每个叶子节点不但存放了索引键的相关信息还增加了指向相邻叶子节点的指针，这样就形成了带有顺序访问指针的B+Tree，做这个优化的目的是提高不同区间访问的性能。 
什么时候使用索引： 
1. 经常出现在group by,order by和distinc关键字后面的字段 
2. 经常与其他表进行连接的表，在连接字段上应该建立索引 
3. 经常出现在Where子句中的字段 
4. 经常出现用作查询选择的字段
### 代理
代理的共有优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。 
Java静态代理： 
代理对象和目标对象实现了相同的接口，目标对象作为代理对象的一个属性，具体接口实现中，代理对象可以在调用目标对象相应方法前后加上其他业务处理逻辑。 
缺点：一个代理类只能代理一个业务类。如果业务类增加方法时，相应的代理类也要增加方法。 
Java动态代理： 
Java动态代理是写一个类实现InvocationHandler接口，重写Invoke方法，在Invoke方法可以进行增强处理的逻辑的编写，这个公共代理类在运行的时候才能明确自己要代理的对象，同时可以实现该被代理类的方法的实现，然后在实现类方法的时候可以进行增强处理。 
实际上：代理对象的方法 = 增强处理 + 被代理对象的方法
JDK和CGLIB生成动态代理类的区别： 
JDK动态代理只能针对实现了接口的类生成代理（实例化一个类）。此时代理对象和目标对象实现了相同的接口，目标对象作为代理对象的一个属性，具体接口实现中，可以在调用目标对象相应方法前后加上其他业务处理逻辑 
CGLIB是针对类实现代理，主要是对指定的类生成一个子类（没有实例化一个类），覆盖其中的方法 。 
Spring AOP应用场景 
性能检测，访问控制，日志管理，事务等。 
默认的策略是如果目标类实现接口，则使用JDK动态代理技术，如果目标对象没有实现接口，则默认会采用CGLIB代理
### HashMap和HashTable
HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。HashMap底层是通过链表来解决hash冲突的。Java8以后选择用平衡树。
HashTable在put时使用synchronized所以是线程安全的，并且不允许key value为null。
HashMap可以通过下面的语句进行同步：
Map m = Collections.synchronizeMap(hashMap);
### CocurrentHashMap
ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。
### Vector和ArrayList的区别
ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。
Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。
### 进程和线程
进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。
线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。
线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。
多进程是指操作系统能同时运行多个任务（程序）。
多线程是指在同一程序中有多个顺序流在执行。
在java中要想实现多线程，有三种手段，一种是继续Thread类，另外一种是实现Runable接口，还有就是实现Callable接口。
### 数据库事务四大特性
原子性：所有操作要么全部成功，要么全部失败回滚。
一致性：数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。
隔离性：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。
### 如何将List转化成int[]？
``` java
int[] array = new int[list.size()];
for(int i = 0; i < list.size(); i++){
    array[i] = list.get(i);
}
```
List.toArray()方法只可能得到Integer[]，无法得到int[]。
### 如何将int[]转化成List？
Arrays.asList()得到的是Integer[]，而且得到的数组是的没有add和remove方法的。因为asList返回的List是Arrays中的内部类,而该类并没有定义add和remove方法。
### 有序的collection
使用Collections.sort()，实现Comparable接口或者自己写Comparator方法。
### synchronized wait notify notifyall
需要配合使用
wait:会把持有该对象线程的对象控制权交出去，然后处于等待状态。
notify:会通知某个正在等待这个对象的控制权的线程可以继续运行。
notifyAll:唤醒所有正在等待这个对象的monitor的线程；
### hashcode和equals
都用来判断对象是否一样。在set类型中，不允许存在相同的对象，这个时候如果有equals一个一个判断，效率太低，使用hashcode根据对象相关信息计算出一个int值，然后判断这个hash值是否存在，如果存在就对比equals，如果一致就不存，如果不一致就散列其他位置。
### 抽象类和接口的区别
a.一个类只能继承单个类，但是可以实现多个接口
b.抽象类中可以有构造方法，接口中不能有构造方法
c.抽象类中的所有方法并不一定要是抽象的，你可以选择在抽象类中实现一些基本的方法。而接口要求所有的方法都必须是抽象的
d.抽象类中可以包含静态方法，接口中不可以
e.抽象类中可以有普通成员变量，接口中不可以
### Dom和Sax
a.DOM：消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机
b.SAX：解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。
### wait和sleep
wait是object方法，sleep是thread的方法，wait会释放资源，等待被notify，而thread不会释放资源，并且一段时间之后自动唤醒。
