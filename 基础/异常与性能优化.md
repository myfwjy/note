---
title: 异常与性能优化 
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---

## ANR
Application Not Responding
主线程中做了耗时操作。Activity 5秒 BroadcastReceiver onReceive 10秒。
### 原因
主线程被IO操作阻塞（网络操作）。
主线程中存在耗时操作。
### 以下操作在主线程
Activity的所有生命周期
Service默认执行在主线程
BroadcastReceiver的onReceive
没有使用子线程的looper创建的Handler的handleMessage，post(Runnable)
AnsyTask除了doInBackgroud方法，其他都在主线程
### 解决
使用AsynTask处理IO操作
使用Thread或者HandlerThread提高优先级
使用handler来处理耗时任务
Activity的onCreat和onResume避免处理耗时操作

## OOM
当前占有的内存加上我们申请的内存超过了Dalvik虚拟机的最大内存限制就会抛出Out of memory异常。(Android为每个App分配了一个虚拟空间，也就是Dalvik虚拟机，保证他们能不受影响的各自运行。)
### 混淆概念
#### 内存溢出
#### 内存抖动
短时间内大量创建对象，大量对象进出Young Generation区，伴随着频繁的GC。
要避免在循环体内创建对象；要避免在自定义view的OnDraw方法中创建对象；对于能够复用的对象，使用缓存，比如bitmap。
#### 内存泄漏
GC会回收那些不是gc root且不被gc root引用的对象，但是有些对象已经废弃但是仍然持有gc root上对象的引用，导致不能正常释放，造成了内存泄漏。
### 解决
#### Bitmap
图片显示
ListView滑动是不加载，停下再加载图片
及时释放内存
使用Bitmap的recycle
图片压缩
比如采样率inSampleSize压缩，小头像显示的时候
inBitmap
复用之前Bitmap图片的内存区域。
捕获异常
注意捕获Out of memory异常。
#### 其他
ListView converview/Lru 最近最少使用策略(LruCache LinkedHashMap 最近访问移到队列头，达到内存上限后移除最后一个)
参考：https://www.cnblogs.com/tianzhijiexian/p/4248677.html
避免在onDraw方法中创建对象
谨慎使用多进程

## Bitmap
### Recyle
移除bitmap在native区域的内容，并且清除指向这部分的引用。不会立即释放内存，而是等GC确认没有其他引用后，并且这个操作不可逆，recyle过后的bitmap不能再进行任何操作。系统建议，这个操作不用特别适用，GC会在Bitmap失去所有引用后自动回收。在实际开发中，可以根据具体情况适用。
### LRU
最近最少算法。内部是一个LinkedHashMap强引用，可以通过put,get,remove等方法操作，最主要的是trimToSize方法，实现删除最少使用缓存，并添加新的缓存。
### inSampleSize
在合适的位置加载合适的大小。采样率。
### 缩率图
BitmapFactory.Options属性inJustDecodeBound
将这个属性设置为true时，返回的bitmap不是真正的bitmap的实际内容，而是只返回bitmap的宽高，并且将返回的宽高存放到outWidth和outHeight这两个字段当中。然后根据这个值去计算具体的采样率，最后得到一个压缩后的图片。
参考：http://blog.csdn.net/weixin_40290793/article/details/78776459
### 三级缓存
先从网络获取，存在内存和本地中，下一次加载图片从缓存中获取。

## UI卡顿
60fps->16ms 1秒60帧 
16ms内完成渲染，就不会卡顿。